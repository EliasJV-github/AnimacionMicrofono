<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Reactive Hexagon</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            background: radial-gradient(ellipse at center, #003366 0%, #001a33 50%, #000000 100%);
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to right, rgba(0, 0, 0, 0.8) 0%, transparent 15%, transparent 85%, rgba(0, 0, 0, 0.8) 100%);
            pointer-events: none;
            z-index: 1;
        }

        .ribbon-container {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
            pointer-events: none;
            opacity: 0;
        }

        .ribbon {
            width: 100%;
            height: 30vw;
            max-height: 300px;
            position: relative;
        }

        .ribbon svg {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 4px 10px rgba(0, 0, 0, 0.3));
        }

        .title {
            text-align: center;
            color: white;
            font-size: clamp(1.5rem, 5vw, 3rem);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 3px;
            padding: 2rem;
            z-index: 10;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .audio-blob-container {
            position: relative;
            z-index: 5;
            display: flex;
            justify-content: center;
            align-items: center;
            width: clamp(250px, 45vw, 450px);
            height: clamp(250px, 45vw, 450px);
        }

        .audio-blob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 123, 255, 0.9), rgba(0, 87, 184, 0.7), rgba(0, 51, 102, 0.5));
            filter: blur(40px) drop-shadow(0 0 60px rgba(0, 123, 255, 0.8)) drop-shadow(0 0 120px rgba(0, 123, 255, 0.5));
            animation: blob-rotate 8s linear infinite, blob-pulse 3s ease-in-out infinite;
        }

        @keyframes blob-rotate {
            0% { transform: rotate(0deg) scale(1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        @keyframes blob-pulse {
            0%, 100% { filter: blur(40px) drop-shadow(0 0 60px rgba(0, 123, 255, 0.8)) drop-shadow(0 0 120px rgba(0, 123, 255, 0.5)); }
            50% { filter: blur(45px) drop-shadow(0 0 80px rgba(0, 123, 255, 0.9)) drop-shadow(0 0 140px rgba(0, 123, 255, 0.6)); }
        }

        .description {
            text-align: center;
            color: rgba(255, 255, 255, 0.85);
            font-size: clamp(0.9rem, 2.5vw, 1.2rem);
            font-weight: 300;
            padding: 2rem;
            max-width: 600px;
            z-index: 10;
            text-shadow: 0 1px 5px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 768px) {
            .title {
                font-size: clamp(1.2rem, 6vw, 2rem);
                letter-spacing: 2px;
            }

            .description {
                font-size: clamp(0.8rem, 3vw, 1rem);
                padding: 1.5rem;
            }

            .audio-blob {
                filter: blur(25px) drop-shadow(0 0 30px rgba(0, 123, 255, 0.5));
            }
        }
    </style>
</head>
<body>
    <h1 class="title">Experiencia Interactiva</h1>

    <div class="ribbon-container">
        <div class="ribbon">
            <svg viewBox="0 0 1200 300" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">
                <!-- Línea de latido/electrocardiograma -->
                <path id="heartbeat-line" 
                      fill="none" 
                      stroke="white" 
                      stroke-width="4" 
                      stroke-linecap="round"
                      opacity="0.6"/>
                <!-- Línea base horizontal -->
                <line x1="0" y1="150" x2="1200" y2="150" 
                      stroke="white" 
                      stroke-width="1" 
                      opacity="0.2"/>
            </svg>
        </div>
    </div>

    <div class="audio-blob-container">
        <div class="audio-blob" id="audioBlob"></div>
    </div>

    <p class="description">
        Permite el acceso al micrófono para una experiencia visual que reacciona al sonido en tiempo real
    </p>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script>
        // Variables para el control de audio
        let audioContext;
        let analyser;
        let microphone;
        let dataArray;
        let animationFrame;
        let isMicActive = false;
        let waveOffset = 0;
        let waveHistory = []; // Historial de amplitudes para efecto de desplazamiento
        let autoWaveTimer = 0;
        let autoWavePhase = 0;

        // Generar ondas automáticas del sistema
        function generateAutoWave() {
            autoWaveTimer++;
            
            // Generar un pulso cada segundo (60 frames aprox)
            if (autoWaveTimer >= 60) {
                autoWaveTimer = 0;
                autoWavePhase = 1; // Activar pulso
            }
            
            // Crear forma de pulso (subida rápida y bajada suave)
            let amplitude = 0;
            if (autoWavePhase > 0) {
                // Curva de pulso tipo campana
                const t = autoWavePhase / 20; // Duración del pulso (20 frames)
                amplitude = 60 * Math.exp(-5 * Math.pow(t - 0.3, 2)); // Curva gaussiana
                autoWavePhase++;
                
                if (autoWavePhase > 20) {
                    autoWavePhase = 0; // Resetear pulso
                }
            }
            
            return amplitude;
        }

        // Animación de onda tipo electrocardiograma/latido con curvas suaves
        function animateHeartbeatWave() {
            const heartbeatLine = document.getElementById('heartbeat-line');
            
            // Obtener amplitud del audio en tiempo real
            let currentAmplitude = 0;
            
            if (isMicActive) {
                const rms = getRMS();
                const audioAmplitude = rms * 120; // Amplitud del audio
                const autoAmplitude = generateAutoWave(); // Pulso automático
                
                // Si hay sonido, usar el audio; si no, usar el pulso automático
                currentAmplitude = Math.max(audioAmplitude, autoAmplitude);
            } else {
                // Sin micrófono, solo usar ondas automáticas
                currentAmplitude = generateAutoWave();
            }
            
            // Agregar la amplitud actual al historial
            waveHistory.push(currentAmplitude);
            
            // Mantener solo los últimos valores necesarios para llenar la pantalla
            const maxPoints = 80;
            if (waveHistory.length > maxPoints) {
                waveHistory.shift();
            }
            
            // Generar el path de la onda con curvas suaves (Bézier)
            let path = 'M 0 150'; // Cambiado centro a 150
            const spacing = 1200 / maxPoints; // Espaciado entre puntos
            
            for (let i = 0; i < waveHistory.length; i++) {
                const x = i * spacing;
                const amplitude = waveHistory[i];
                
                // Alternar entre positivo y negativo para efecto de onda
                const direction = Math.sin(i * 0.5) > 0 ? 1 : -1;
                const y = 150 + (amplitude * direction); // Cambiado centro a 150
                
                if (i === 0) {
                    path += ` L ${x} ${y}`;
                } else {
                    // Usar curvas cuadráticas para suavizar
                    const prevX = (i - 1) * spacing;
                    const prevAmplitude = waveHistory[i - 1];
                    const prevDirection = Math.sin((i - 1) * 0.5) > 0 ? 1 : -1;
                    const prevY = 150 + (prevAmplitude * prevDirection); // Cambiado centro a 150
                    
                    // Punto de control en el medio
                    const cpX = (prevX + x) / 2;
                    const cpY = (prevY + y) / 2;
                    
                    path += ` Q ${cpX} ${cpY}, ${x} ${y}`;
                }
            }
            
            // Completar el resto del path hasta el final con curva suave
            if (waveHistory.length < maxPoints) {
                const lastX = waveHistory.length * spacing;
                path += ` Q ${(lastX + 1200) / 2} 150, 1200 150`; // Cambiado centro a 150
            }
            
            heartbeatLine.setAttribute('d', path);
            
            waveOffset++;
            requestAnimationFrame(animateHeartbeatWave);
        }

        // Respiración y rotación del blob por defecto
        let breatheAnimation = anime({
            targets: '#audioBlob',
            scale: [1, 1.15, 1],
            duration: 3500,
            easing: 'easeInOutSine',
            loop: true
        });

        // Función para inicializar el micrófono
        async function initMicrophone() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.8;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                microphone.connect(analyser);
                
                isMicActive = true;
                breatheAnimation.pause();
                updateAudioBlob();
            } catch (error) {
                console.log('Micrófono no disponible, usando animación por defecto');
            }
        }

        // Función para calcular RMS con suavizado
        function getRMS() {
            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const normalized = (dataArray[i] - 128) / 128;
                sum += normalized * normalized;
            }
            return Math.sqrt(sum / dataArray.length);
        }

        // Variables para suavizado
        let currentScale = 1;
        let targetScale = 1;

        // Función para actualizar el blob con suavizado
        function updateAudioBlob() {
            if (!isMicActive) return;

            const rms = getRMS();
            targetScale = 1 + (rms * 2.5); // Escala entre 1 y 3.5 (muy reactivo)
            
            // Suavizado (lerp)
            currentScale += (targetScale - currentScale) * 0.2;
            
            const blob = document.getElementById('audioBlob');
            blob.style.transform = `scale(${currentScale})`;
            blob.style.transition = 'transform 0.15s ease-out';

            animationFrame = requestAnimationFrame(updateAudioBlob);
        }

        // Iniciar animaciones
        animateHeartbeatWave();
        initMicrophone();

        // Limpiar al salir
        window.addEventListener('beforeunload', () => {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            if (audioContext) {
                audioContext.close();
            }
        });
    </script>
</body>
</html>